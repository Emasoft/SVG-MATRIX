/**
 * SVG Issues Domain Test
 *
 * Uses Chrome DevTools Protocol "Audits" and "Inspector" domains
 * to capture browser-level issues that may not appear in console.
 *
 * Some Chrome warnings (like duplicate IDs in SVG, invalid attributes)
 * are generated by the rendering engine and may not go through the
 * standard Console/Log CDP domains.
 */

import { chromium } from 'playwright';
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import http from 'node:http';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SVG_PATH = path.join(__dirname, '../samples/SVG_WITH_EMBEDDED_AUDIO/cartoon_sample_with_audio.svg');

async function testWithIssuesDomain(svgPath) {
  console.log('='.repeat(70));
  console.log('SVG Issues Domain Test (Audits, Inspector, CSS, DOM)');
  console.log('='.repeat(70));
  console.log(`\nSVG File: ${svgPath}`);

  const svgContent = await fs.readFile(svgPath, 'utf8');
  console.log(`File size: ${(svgContent.length / 1024).toFixed(2)} KB`);

  // Create HTTP server
  const server = http.createServer((req, res) => {
    if (req.url === '/test.svg') {
      res.writeHead(200, { 'Content-Type': 'image/svg+xml' });
      res.end(svgContent);
    } else {
      res.writeHead(404);
      res.end('Not found');
    }
  });

  await new Promise(resolve => server.listen(0, '127.0.0.1', resolve));
  const port = server.address().port;
  const svgUrl = `http://127.0.0.1:${port}/test.svg`;

  console.log(`\nServing SVG at: ${svgUrl}`);

  const browser = await chromium.launch({
    headless: true,
    args: [
      '--disable-web-security',
      '--autoplay-policy=no-user-gesture-required',
    ],
  });

  const context = await browser.newContext();
  const page = await context.newPage();

  const allIssues = [];

  // Get CDP session BEFORE any navigation
  const client = await page.context().newCDPSession(page);

  // Enable ALL possible domains that might capture issues
  const domainsToEnable = [
    'Log',
    'Console',
    'Runtime',
    'DOM',
    'CSS',
    'Audits',
    'Inspector',
    'Page',
  ];

  for (const domain of domainsToEnable) {
    try {
      await client.send(`${domain}.enable`);
      console.log(`  [CDP] ${domain} domain enabled`);
    } catch (e) {
      console.log(`  [CDP] ${domain} domain not available: ${e.message}`);
    }
  }

  // Listen to Audits.issueAdded - this captures browser-level issues
  client.on('Audits.issueAdded', (params) => {
    const issue = params.issue;
    console.log(`\n[AUDIT ISSUE] Code: ${issue.code}`);
    console.log(`  Details: ${JSON.stringify(issue.details, null, 2)}`);
    allIssues.push({
      type: 'Audits',
      code: issue.code,
      details: issue.details,
    });
  });

  // Listen to Inspector.detached
  client.on('Inspector.detached', (params) => {
    console.log(`[INSPECTOR] Detached: ${params.reason}`);
  });

  // Listen to Inspector.targetCrashed
  client.on('Inspector.targetCrashed', () => {
    console.log(`[INSPECTOR] Target crashed!`);
    allIssues.push({ type: 'crash', text: 'Target crashed' });
  });

  // Listen to CSS.styleSheetAdded for CSS issues
  client.on('CSS.styleSheetAdded', (params) => {
    console.log(`[CSS] StyleSheet added: ${params.header?.sourceURL || 'inline'}`);
  });

  // DOM.documentUpdated
  client.on('DOM.documentUpdated', () => {
    console.log(`[DOM] Document updated`);
  });

  // Page.lifecycleEvent
  client.on('Page.lifecycleEvent', (params) => {
    console.log(`[PAGE] Lifecycle: ${params.name}`);
  });

  // Standard log/console capture
  client.on('Log.entryAdded', (params) => {
    const entry = params.entry;
    console.log(`[LOG ${entry.level}] ${entry.source}: ${entry.text}`);
    allIssues.push({
      type: 'Log',
      level: entry.level,
      source: entry.source,
      text: entry.text,
    });
  });

  client.on('Runtime.consoleAPICalled', (params) => {
    const args = params.args.map(a => a.value || a.description || '[object]').join(' ');
    console.log(`[CONSOLE ${params.type}] ${args}`);
    allIssues.push({
      type: 'Console',
      level: params.type,
      text: args,
    });
  });

  client.on('Runtime.exceptionThrown', (params) => {
    const ex = params.exceptionDetails;
    console.log(`[EXCEPTION] ${ex.text}`);
    allIssues.push({
      type: 'Exception',
      text: ex.text,
      description: ex.exception?.description,
    });
  });

  // Playwright handlers
  page.on('console', msg => {
    console.log(`[PW ${msg.type()}] ${msg.text()}`);
  });

  page.on('pageerror', error => {
    console.log(`[PAGE_ERROR] ${error.message}`);
    allIssues.push({ type: 'PageError', text: error.message });
  });

  console.log('\n--- Loading SVG ---');

  try {
    await page.goto(svgUrl, { waitUntil: 'networkidle', timeout: 30000 });
  } catch (e) {
    console.log(`Navigation error: ${e.message}`);
  }

  // Wait for issues to be reported
  console.log('\n--- Waiting for delayed issues (5 seconds) ---');
  await page.waitForTimeout(5000);

  // Try to get computed styles and detect rendering issues
  const renderInfo = await page.evaluate(() => {
    const svg = document.querySelector('svg');
    if (!svg) return { error: 'No SVG element' };

    const foreignObjects = svg.querySelectorAll('foreignObject');
    const foreignObjectIssues = [];

    for (const fo of foreignObjects) {
      const computed = getComputedStyle(fo);
      const hasWidth = fo.hasAttribute('width') || computed.width !== 'auto';
      const hasHeight = fo.hasAttribute('height') || computed.height !== 'auto';

      if (!fo.hasAttribute('width') || !fo.hasAttribute('height')) {
        foreignObjectIssues.push({
          hasWidthAttr: fo.hasAttribute('width'),
          hasHeightAttr: fo.hasAttribute('height'),
          computedWidth: computed.width,
          computedHeight: computed.height,
        });
      }
    }

    // Check for other potential issues
    const elementsWithInvalidAttrs = [];
    const allElements = svg.querySelectorAll('*');

    for (const el of allElements) {
      // Check for NaN or Infinity in transform
      const transform = el.getAttribute('transform');
      if (transform && (transform.includes('NaN') || transform.includes('Infinity'))) {
        elementsWithInvalidAttrs.push({
          tag: el.tagName,
          attr: 'transform',
          value: transform,
        });
      }

      // Check for negative dimensions
      const width = el.getAttribute('width');
      const height = el.getAttribute('height');
      if (width && parseFloat(width) < 0) {
        elementsWithInvalidAttrs.push({ tag: el.tagName, attr: 'width', value: width });
      }
      if (height && parseFloat(height) < 0) {
        elementsWithInvalidAttrs.push({ tag: el.tagName, attr: 'height', value: height });
      }
    }

    return {
      foreignObjectCount: foreignObjects.length,
      foreignObjectIssues,
      invalidAttrsCount: elementsWithInvalidAttrs.length,
      invalidAttrs: elementsWithInvalidAttrs.slice(0, 10),
    };
  });

  console.log('\n--- Render Info ---');
  console.log(JSON.stringify(renderInfo, null, 2));

  if (renderInfo.foreignObjectIssues?.length > 0) {
    console.log('\n[ISSUE] foreignObject elements without width/height attributes');
    allIssues.push({
      type: 'Validation',
      text: 'foreignObject missing width/height',
      details: renderInfo.foreignObjectIssues,
    });
  }

  if (renderInfo.invalidAttrsCount > 0) {
    console.log('\n[ISSUE] Elements with invalid attribute values');
    allIssues.push({
      type: 'Validation',
      text: 'Invalid attribute values',
      details: renderInfo.invalidAttrs,
    });
  }

  await browser.close();
  server.close();

  // Summary
  console.log('\n' + '='.repeat(70));
  console.log('ALL CAPTURED ISSUES');
  console.log('='.repeat(70));

  if (allIssues.length === 0) {
    console.log('No issues captured via CDP domains');
    console.log('\nNote: Some browser warnings are displayed directly in DevTools');
    console.log('but are not exposed through any CDP domain. Examples include:');
    console.log('  - Duplicate ID warnings in SVG');
    console.log('  - Browser-specific SVG rendering differences');
    console.log('  - CSS/SVG property warnings');
    console.log('  - Verbose-level internal messages');
  } else {
    for (const issue of allIssues) {
      console.log(`[${issue.type}] ${issue.text || issue.code || 'no description'}`);
    }
  }

  return allIssues;
}

testWithIssuesDomain(SVG_PATH)
  .then(issues => {
    console.log(`\nTotal issues captured: ${issues.length}`);
    process.exit(issues.length > 0 ? 1 : 0);
  })
  .catch(err => {
    console.error('Test failed:', err);
    process.exit(1);
  });
